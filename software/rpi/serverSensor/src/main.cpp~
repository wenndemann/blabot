#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <strings.h>
#include <string>
#include <map>
#include <algorithm>

#include <unistd.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <math.h>


#include "../../include/defs.h"
#include "i2c.h"
#include "tools.h"
// SERVER

#define SEMM_NUM_THREADS 8


pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_t g_threads[SEMM_NUM_THREADS];
pthread_t i2cThread;
sensorData_s sensorData;


void* tcp_accept_players(void* arg);
void* i2c_sensor_read(void* arg);


void error(const char *msg)
{
	// TODO
	// __line__
	// __file__
    perror(msg);
    exit(1);
}


int main(int argc, char** argv)
{
	if (system("clear") != 0) //Bildschrirm l√∂schen
		error("clear failed!");

	int sockfd, newsockfd, portno;
	std::map<int, tcp_data> mapTcpData;
	socklen_t clilen;
	struct sockaddr_in serv_addr, cli_addr;
	int numAcceptions = 0;

	// intialize server
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) 
	error("ERROR opening socket");
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = SEMM_TCPIP_PORT;

	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);

	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) 
		error("ERROR on binding");
	
	if(pthread_mutex_init(&g_mutex, NULL))
		error("Faild to initialize mutex");
	if (pthread_create(&i2cThread, NULL, i2c_sensor_read, NULL))
		error("Faild to create i2c thread!");

	while(true) {
		
		// TODO accept multiple users
		// waiting for clients
		listen(sockfd,5);
		clilen = sizeof(cli_addr);
		
		newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
		tcp_data data(newsockfd);
		mapTcpData[numAcceptions] = data;

		if (newsockfd < 0) 
		  error("ERROR on accept");
		
		if (pthread_create(&g_threads[numAcceptions], NULL, tcp_accept_players, 
			(void*) &mapTcpData[numAcceptions]))
        { error("Failed to create user acceptance thread"); }
		
		numAcceptions++;
		if (numAcceptions >= SEMM_NUM_THREADS)
			close(newsockfd);
	}

	close(sockfd);
		
	return 0; 
}


void* i2c_sensor_read(void* arg) {
	uint8_t temp;
	uint8_t l, h;
	int16_t bla;
	I2c i2c("/dev/i2c-0");


	__MSG("initialize hardware\n");
	temp = 0x08;
	i2c.send(ACCEL_ADDR, ACCEL_POWER_CTL, &temp, sizeof(temp));
	i2c.send(ACCEL_ADDR, ACCEL_DATA_FORMAT, &temp, sizeof(temp));

  temp = 0x80;
	i2c.send(GYRO_ADDR, GYRO_POWER_CTL, &temp, sizeof(temp));
  temp = 0x09;
	i2c.send(GYRO_ADDR, GYRO_DLPF_FS, &temp, sizeof(temp));
  temp = 0x02;
	i2c.send(GYRO_ADDR, GYRO_POWER_CTL, &temp, sizeof(temp));

	sleep(1);
	__MSG("start reading sensor data\n");
	while(1) {
		pthread_mutex_lock(&g_mutex);
		i2c.receive(ACCEL_ADDR, ACCEL_X, &sensorData.accel[0], 
			sizeof(sensorData.accel[0]));
		i2c.receive(ACCEL_ADDR, ACCEL_Y, &sensorData.accel[1], 
			sizeof(sensorData.accel[1]));
		i2c.receive(ACCEL_ADDR, ACCEL_Z, &sensorData.accel[2], 
			sizeof(sensorData.accel[2]));
		
		i2c.receive(GYRO_ADDR, GYRO_X, &h, sizeof(h));
		i2c.receive(GYRO_ADDR, GYRO_X + 1, &l, sizeof(l));
		sensorData.gyro[0] = (((short) (l | (h << 8)))>>3)+1;
		
		i2c.receive(GYRO_ADDR, GYRO_Y, &h, sizeof(h));
		i2c.receive(GYRO_ADDR, GYRO_Y + 1, &l, sizeof(l));
		sensorData.gyro[1] = (((short) (l | (h << 8)))>>0)+1;
		
		i2c.receive(GYRO_ADDR, GYRO_Z, &h, sizeof(h));
		i2c.receive(GYRO_ADDR, GYRO_Z + 1, &l, sizeof(l));
		sensorData.gyro[2] = (((short) (l | (h << 8)))>>0)+1;
		
		
		
		pthread_mutex_unlock(&g_mutex);
		//printf("gyro \t  %d\n",bla);
		usleep(1000000);
	}
	return NULL;
}


struct werte_s {
	int16_t a,b,c;
}werte;


void* tcp_accept_players(void* arg) 
{
	int n;
	tcp_data data = *((tcp_data*) arg);
	
	__MSG("user %d connected\n", data.newsockfd);
	
	while(true) 
	{
		//werte.a = (int16_t) ((rand() % 1000) - 500);
		//werte.b = (int16_t) ((rand() % 500));
		//werte.c = (int16_t) ((rand() % 100) - 200);
		pthread_mutex_lock(&g_mutex);
		n = write(data.newsockfd, (void*) &sensorData , sizeof(sensorData));
		pthread_mutex_unlock(&g_mutex);
		if (n < 0) error("ERROR writing to socket");
		usleep(50000);
	}

	return NULL;
}









